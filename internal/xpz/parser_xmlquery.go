package xpz

import (
	"os"
	"regexp"
	"strings"

	"github.com/antchfx/xmlquery"
	"github.com/rubensantoniorosa2704/gxdocgen/internal/model"
	"github.com/rubensantoniorosa2704/gxdocgen/internal/parser"
	"github.com/rubensantoniorosa2704/gxdocgen/internal/utils"
)

// parseGXExportFileXMLQuery parses GX export using xmlquery (refactored version)
func parseGXExportFileXMLQuery(filePath string) ([]model.GXObject, string, error) {
	xmlFile, err := os.Open(filePath)
	if err != nil {
		return nil, "", err
	}
	defer xmlFile.Close()

	doc, err := xmlquery.Parse(xmlFile)
	if err != nil {
		return nil, "", err
	}

	// Extract KB Name from Source/Version/@name
	kbName := GetAttr(doc, "//Source/Version", "name")

	// Find all Object nodes
	objectNodes := FindAll(doc, "//Objects/Object")
	if len(objectNodes) == 0 {
		return nil, kbName, nil
	}

	var objects []model.GXObject
	seenObjects := make(map[string]bool)

	for _, objNode := range objectNodes {
		// Extract object attributes
		objName := GetAttrDirect(objNode, "name")
		objType := GetAttrDirect(objNode, "type")
		objDescription := GetAttrDirect(objNode, "description")
		objParent := GetAttrDirect(objNode, "parent")
		objUser := GetAttrDirect(objNode, "user")

		// Map type GUID to name
		typeName := gxTypeMap[objType]
		if typeName == "" || typeName == "Unknown" {
			continue
		}

		// Skip duplicates
		objKey := objName + "|" + objType
		if seenObjects[objKey] {
			continue
		}
		seenObjects[objKey] = true

		// Use description as display name if available
		displayName := objName
		if objDescription != "" {
			displayName = objDescription
		}

		// Process based on type
		if typeName == "Procedure" {
			gxObj, shouldInclude := parseProcedure(objNode, objName, displayName, objDescription, objParent, objUser)
			if shouldInclude {
				objects = append(objects, gxObj)
			}
		}
		// Future: Add Data Provider, WebPanel, etc.
	}

	return objects, kbName, nil
}

// parseProcedure extracts all procedure information.
// Returns the GXObject and a boolean indicating whether it should be included in documentation.
func parseProcedure(objNode *xmlquery.Node, name, displayName, xmlDescription, parent, xmlUser string) (model.GXObject, bool) {
	// Extract source code
	sourceCode := GetText(objNode, "//Part[@type='"+GXPartSourceCode+"']/Source")
	sourceCode = strings.TrimSpace(sourceCode)

	// Extract signature with multi-layer fallback
	sig := ExtractProcedureSignature(objNode, name)
	
	// Check if procedure is empty or only contains comments
	hasRealCode := sourceCode != "" && !isOnlyComments(sourceCode)
	hasParameters := len(sig.Parameters) > 0
	
	// Skip empty procedures with no parameters
	if !hasRealCode && !hasParameters {
		utils.Warning("Skipping empty procedure '%s' (no code or parameters)", name)
		return model.GXObject{}, false
	}
	
	// Enrich parameters with Variable metadata
	sig.Parameters = EnrichWithVariableMetadata(sig.Parameters, objNode)

	// Parse documentation from source code comments
	var documentation *model.DocComment
	if sourceCode != "" {
		doc, err := parser.Parse(sourceCode)
		if err != nil {
			utils.Warning("Failed to parse documentation for %s: %v", name, err)
		} else {
			documentation = doc
		}
	}

	// Determine if auto-generated and handle parameter merging
	if documentation == nil {
		// No annotations found - create auto-generated doc
		documentation = &model.DocComment{
			IsAutoGenerated: true,
			Parameters:      sig.Parameters,
			Tags:            make([]string, 0),
		}
	} else {
		// Has annotations - merge parameters if @param not used
		if len(documentation.Parameters) == 0 && len(sig.Parameters) > 0 {
			documentation.Parameters = sig.Parameters
		}
	}

	// Add author from XML if not in annotations
	if documentation != nil && documentation.Author == "" {
		if xmlUser != "" {
			documentation.Author = xmlUser
		} else {
			documentation.Author = "Unknown"
		}
	}

	// Determine package with fallback logic
	packageName := determinePackage(documentation, parent, name)
	if documentation != nil {
		documentation.Package = packageName
	}

	// Generate summary with fallback
	summary := determineSummary(documentation, name)
	if documentation != nil && documentation.Summary == "" {
		documentation.Summary = summary
	}

	// Generate description with fallback
	description := determineDescription(documentation, name, xmlDescription)
	if documentation != nil && documentation.Description == "" {
		documentation.Description = description
	}

	return model.GXObject{
		Name:           displayName,
		Type:           "Procedure",
		Path:           name,
		SourceCode:     sourceCode,
		ParmSignature:  sig.RawSignature,
		XMLDescription: xmlDescription,
		Documentation:  documentation,
	}, true
}

// isOnlyComments checks if source code contains only comments and whitespace.
func isOnlyComments(source string) bool {
	lines := strings.Split(source, "\n")
	for _, line := range lines {
		trimmed := strings.TrimSpace(line)
		// Skip empty lines
		if trimmed == "" {
			continue
		}
		// If we find a non-comment line, there's real code
		if !strings.HasPrefix(trimmed, "//") && !strings.HasPrefix(trimmed, "/*") && !strings.HasPrefix(trimmed, "*") {
			return false
		}
	}
	return true
}

// determinePackage implements package fallback logic
// Priority: @package/@tag → Parent/module → name prefix → "Root"
func determinePackage(doc *model.DocComment, parent, name string) string {
	// 1. Check @package or @tag from annotations
	if doc != nil && doc.Package != "" {
		return doc.Package
	}
	if doc != nil && len(doc.Tags) > 0 {
		return doc.Tags[0]
	}

	// 2. Use GeneXus Parent/module if available
	if parent != "" {
		return parent
	}

	// 3. Infer from procedure name prefix (e.g., CustomerInsert → Customer)
	if prefix := inferPackageFromName(name); prefix != "" {
		return prefix
	}

	// 4. Default to Root
	return "Root"
}

// inferPackageFromName tries to extract a package name from the procedure name
// Example: CustomerInsert → "customer", prLoadUser → "user", GetUserByID → "user"
func inferPackageFromName(name string) string {
	// Remove common prefixes
	if strings.HasPrefix(name, "pr_") {
		name = strings.TrimPrefix(name, "pr_")
	} else if strings.HasPrefix(name, "pr") && len(name) > 2 && name[2] >= 'A' && name[2] <= 'Z' {
		name = name[2:]
	}
	
	// Look for first word in CamelCase
	// Match: Capital letter followed by lowercase letters
	// OR: Multiple capitals (like API, HTTP) followed by capital+lowercase or end
	re := regexp.MustCompile(`^([A-Z][a-z]+|[A-Z]+)`)
	matches := re.FindStringSubmatch(name)
	if len(matches) > 1 {
		return strings.ToLower(matches[1])
	}

	return ""
}

// determineSummary implements summary fallback logic
// Priority: @summary → inferred from name → auto-generated
func determineSummary(doc *model.DocComment, name string) string {
	// 1. Use @summary if available
	if doc != nil && doc.Summary != "" {
		return doc.Summary
	}

	// 2. Infer from procedure name
	if inferred := inferSummaryFromName(name); inferred != "" {
		return inferred
	}

	// 3. Auto-generated fallback
	return "Auto-generated summary for " + name
}

// inferSummaryFromName tries to generate a summary from the procedure name
// Example: InsertUser → "Insert User", GetUserByID → "Get User By ID"
func inferSummaryFromName(name string) string {
	// Add spaces before uppercase letters that follow lowercase letters
	re := regexp.MustCompile(`([a-z])([A-Z])`)
	spaced := re.ReplaceAllString(name, "$1 $2")
	
	// Add spaces before uppercase letters that are followed by lowercase (for acronyms)
	// e.g., "UserID" -> "User ID"
	re2 := regexp.MustCompile(`([A-Z]+)([A-Z][a-z])`)
	spaced = re2.ReplaceAllString(spaced, "$1 $2")
	
	return spaced
}

// determineDescription implements description fallback logic
// Priority: @description → XML description → auto-generated
func determineDescription(doc *model.DocComment, name, xmlDescription string) string {
	// 1. Use @description if available
	if doc != nil && doc.Description != "" {
		return doc.Description
	}

	// 2. Use XML description attribute if available
	if xmlDescription != "" {
		return xmlDescription
	}

	// 3. Auto-generated fallback
	return "Auto-generated description for " + name + ". Add @description to improve this."
}
